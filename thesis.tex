%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% I, the copyright holder of this work, release this work into the
%% public domain. This applies worldwide. In some countries this may
%% not be legally possible; if so: I grant anyone the right to use
%% this work for any purpose, without any conditions, unless such
%% conditions are required by law.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[
  digital,     %% The `digital` option enables the default options for the
               %% digital version of a document. Replace with `printed`
               %% to enable the default options for the printed version
               %% of a document.
%%  color,       %% Uncomment these lines (by removing the %% at the
%%               %% beginning) to use color in the printed version of your
%%               %% document
  oneside,     %% The `oneside` option enables one-sided typesetting,
               %% which is preferred if you are only going to submit a
               %% digital version of your thesis. Replace with `twoside`
               %% for double-sided typesetting if you are planning to
               %% also print your thesis. For double-sided typesetting,
               %% use at least 120 g/m² paper to prevent show-through.
  nosansbold,  %% The `nosansbold` option prevents the use of the
               %% sans-serif type face for bold text. Replace with
               %% `sansbold` to use sans-serif type face for bold text.
  nocolorbold, %% The `nocolorbold` option disables the usage of the
               %% blue color for bold text, instead using black. Replace
               %% with `colorbold` to use blue for bold text.
  lof,         %% The `lof` option prints the List of Figures. Replace
               %% with `nolof` to hide the List of Figures.
  lot,         %% The `lot` option prints the List of Tables. Replace
               %% with `nolot` to hide the List of Tables.
    % draft,
]{fithesis4}
%% The following section sets up the locales used in the thesis.
\usepackage[resetfonts]{cmap} %% We need to load the T2A font encoding
\usepackage[
  main=english, %% By using `czech` or `slovak` as the main locale
                %% instead of `english`, you can typeset the thesis
                %% in either Czech or Slovak, respectively.
  english, czech %% The additional keys allow
]{babel}        %% foreign texts to be typeset as follows:
%%

\newcommand{\TODO}[1]{\textcolor{red}{\textit{#1}}}
\newcommand{\TODOLIST}[1]{\TODO{#1}}

%% The following section sets up the metadata of the thesis.
\thesissetup{
    date        = \the\year/\the\month/\the\day,
    university  = mu,
    faculty     = fi,
    type        = bc,
    department  = \TODO{Department of Machine Learning and Data Processing},
    author      = Petr Bém,
    gender      = m,
    advisor     = {RNDr. Jan Mrázek},
    title       = {Firmware for RoFICoM},
    TeXtitle    = {Firmware for \acrshort{roficom}},
    keywords    = {\TODO{modular, robots, RoFI, firmware}},
    TeXkeywords = {\TODO{keyword1, keyword2, \ldots}},
    abstract    = {%
      This is the abstract of my thesis, which can

      span multiple paragraphs.
    },
    thanks      = {%
      These are the acknowledgments for my thesis, which can

      span multiple paragraphs.
    },
    bib         = citations.bib,
    %% Remove the following line to use the JVS 2018 faculty logo.
    facultyLogo = fithesis-fi,
}
\usepackage{makeidx}      %% The `makeidx` package contains
\makeindex                %% helper commands for index typesetting.
\usepackage{hyperref}
\usepackage[acronym]{glossaries}          %% The `glossaries` package
\renewcommand*\glspostdescription{\hfill} %% contains helper commands
\loadglsentries{terms-abbrs.tex}  %% for typesetting glossaries
\makenoidxglossaries                      %% and lists of abbreviations.
%% These additional packages are used within the document:
\usepackage{paralist} %% Compact list environments
\usepackage{amsmath}  %% Mathematics
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{siunitx} %% SI units
\usepackage{url}      %% Hyperlinks
\usepackage{markdown} %% Lightweight markup
\usepackage{listings} %% Source code highlighting
\lstset{
  basicstyle      = \ttfamily,
  identifierstyle = \color{black},
  keywordstyle    = \color{blue},
  keywordstyle    = {[2]\color{cyan}},
  keywordstyle    = {[3]\color{olive}},
  stringstyle     = \color{teal},
  commentstyle    = \itshape\color{magenta},
  breaklines      = true,
  language        = c++,
}
\usepackage{floatrow} %% Putting captions above tables
\floatsetup[table]{capposition=top}
\usepackage[babel]{csquotes} %% Context-sensitive quotation marks
\usepackage{xcolor}
\usepackage{graphicx}
\graphicspath{ {./assets/} }

\usepackage{todonotes} % colorful TODO notes, REMOVE

\usepackage{titlesec,titlecaps}

\begin{document}
%% Uncomment the following lines (by removing the %% at the beginning)
%% and to print out List of Abbreviations and/or Glossary in your
%% document. Titles for these tables can be changed by replacing the
%% titles `Abbreviations` and `Glossary`, respectively.
\clearpage
\printnoidxglossary[title={Abbreviations}, type=\acronymtype]
\printnoidxglossary[title={Glossary}]

\chapter{Introduction}

\chapter[ RoFI ]{ \acrshort{rofi} }
\TODOLIST{
\begin{itemize}
    \item Describe the platform
    \item Universal module
\end{itemize}
}

The \acrshort{rofi} is a platform of distributed self-reconfigurable modular robots developed at Masaryk University, Faculty of Informatics.

The main goal of the \acrshort{rofi} platform is to provide well established open-source and open-hardware platform for metamorphic robots. Thus both source-code and hardware schematics are provided publicly in the \TODO{ Github repository \footcite[\url{https://github.com/paradise-fi/RoFI}]{rofi-github} }. The primary use case for such platform is testing reconfiguring algorithms on a hardware platform and further research into this topic rather than \TODO{solving real-world problems}.

\TODO{\Glspl{rofibot}}

The basic building block is the \acrshort{rofi} module, which is an individual module that can connect and communicate with other modules. A \TODO{flock} of connected \acrshort{rofi} modules makes a \emph{\gls{rofibot}}. A concrete example for the \acrshort{rofi} module is the \gls{universal-module}.


\section[ Universal Module ]{ \gls{universal-module} }
\TODOLIST{
    \begin{itemize}
        \item ESP32
        \item SPI
        \item UART
        \item accumulator
        \item EXT and INT power lines
        \item 3 motors
        \item 6 docks
    \end{itemize}
}
\gls{universal-module} \glsdesc{universal-module} The \gls{universal-module} is not designed as all-in-one module, but rather as a module with minimal \TODO{necessary features} that can be used in nearly all systems. Thus, \gls{universal-module} uses only two sensors: an \emph{inertial measurement unit} (IMU) and a \emph{distance sensor} (\acrshort{lidar}). If specific sensors are needed, it is expected to use them as own modules.

\TODO{IMU}

\TODO{\acrshort{lidar}}
The distance sensor (\acrshort{lidar}) is placed in the middle of each dock and is in detail described in its own chapter \ref{sec:lidar}. The \acrshort{lidar} measures the distance from the dock \TODO{...} or to help align docks when connecting. \TODO{The \acrshort{lidar} also scans the environment, which can be useful when the rofibot needs to walk up stairs, or so ...}

The module is divided into four component: two bodies and two shoes. The main purpose of shoes is to establish connections with other modules and provide movement. Each shoe contains three docks and \TODO{one joint}. Whereas the body encloses actuators, electronics, and accumulators. There is one last \TODO{joint} between the two bodies. In total the module contains six docks and three \TODO{joints/motors} and the two types of sensors.

\todo{Insert image of \gls{universal-module}}

\subsection{ Architecture }

The docks used in the \gls{universal-module} are called \acrshortpl{roficom} and \TODO{are the most important part of this thesis}. The \acrshort{roficom} is in detail described and explained in the next chapter \ref{roficom}.

Each module has a single \emph{control unit} that serves as a centralized control over modules actions and all the module components. The motors are controlled trough UART protocol and docks are controlled over SPI protocol. The control unit also controls charging and power management.

\todo{Add \gls{universal-module} internal architecture diagram}


\chapter[ RoFICoM ]{ \acrshort{roficom} } \label{roficom}
\TODOLIST{
\begin{itemize}
    \item Explain \acrshort{roficom}
    \item Describe components -- shirt, clip and body
    \item Describe board -- RAM: 36KB, Flash: 128KB, ...
\end{itemize}
}

\iffalse
<!--
- Connection/Communication part of RoFI Platform
- Designed to be stand-alone unit (so it can be reused in other modules)
- What it consists of?
    - Docks Interaction
    - Docks power-sharing
-->
\fi

\acrlong{roficom}, \acrshort{roficom} for short, is an open-hardware connection system designed for the \acrshort{rofi} platform. \acrshort{roficom} focuses on reusability \TODO{in order to make it easily integrable} into any module for which \acrshort{roficom} provides
communication to other modules. As the name suggests, its primary purpose is to (inter)connect modules. To achieve \TODO{this}, \acrshort{roficom} has a well-defined interface that can be divided into three parts:
\begin{itemize}
    \item mechanical structure,
    \item connector-to-connector interface (communication between two \acrshortpl{roficom}),
    \item connector-to-module interface (communication with the integrated module).
\end{itemize}

\begin{figure}
    % responsive_image path: assets/img/connector/roficom_main_sketch.jpg
    \includegraphics{ roficom_main_sketch.jpg }
    \caption{ \TODO{ Current look of \acrshort{roficom} } }
\end{figure}

\section{Mechanical structure}
\iffalse
<!--
- Describe individual parts: body, clip and skirt
- Magnets in skirt to ease/join the connecting
- extrating and retracting  - motors
- ?? lidar - I2C
-->
\fi

RoFICoM is built from three main parts: \emph{body}, \emph{clip} and \emph{skirt}. These three parts are shown in figure \ref{ fig:key-components }

\begin{figure}
    %responsive_image path: assets/img/connector/dock_key_components.svg 
    \includegraphics{ dock_key_components.pdf }
    \caption{ \TODO{ Visual representation of main components } \TODO{Add citation} }
    \label{ fig:key-components }
\end{figure}

The body is non-movable part that is mounted into the module.
Clip and skirt are the most important parts for establishing strong mechanical connections between two \acrshortpl{roficom}.
The clip component consists of four latches attached to a ring. Those latches get attached while connecting with
other \acrshort{roficom}. While expanding, the clip gets rotated and expanded upward by the motor. In the process, the latches on the mating
side slide under each other, therefore forming a mechanical connection that prevents connectors from being pulled apart.
However, the latches themselves are insufficient for a mechanical connection, as a mutual rotation of the connectors releases
the connection. This is why the skirt is needed. Two connected skirts stop the rotation against each other.

In order to help and/or ease the process of connection there are magnets placed in the holes of skirt. This helps when two connecting sides are slightly misaligned.

The motor that rotates the clip and the skirt are located at the bottom of the body. To rotate the clip and the skirt there is another component (shaft ring) that is connected to the clip and has a bevel gearing (stair like ramp) connected to the motor. When motor activates it rotates the shaft ring and moves among the gearing elevating the components. The motor in body and clip shaft with a bevel gearing is shown in the figure \ref{ fig:dock-arrangement }

\begin{figure}
    \centering
    % responsive_image path: assets/img/connector/dock_arrangement.svg
    \includegraphics{ dock_arrangement.pdf }
    \caption{ \TODO{ Visual representation of body with motor and shaft ring } \TODO{Add citation} }
    \label{ fig:dock-arrangement }
\end{figure}

\iffalse
\subsection{ Ratings }
\begin{itemize}
    \item compact, flat layout (diameter 50 mm, thickness 17 mm)
    \item data and power sharing between connected units
    \item load capacity
        \item normal direction: 110 N
        \item shear direction: 50 N
    \item actuation time: less than 0.6 s
    \item genderless, 90-degree symmetrical with automatic orientation detection
\end{itemize}
\fi

\section{ Connector to Connector Interface }
\iffalse
<!--
- UART
- data and power sharing - EXT and INT power lanes 
-->
\fi

Connector to connector is done by small PCB inside skirt with spring-loaded pins for connection. This PCB provides both
data and power sharing to the connected module.
For data communication RoFICoM uses \textbf{UART} transferring frames with specified format and CRC. Those frames hold ``blobs'' --
binary data that is transferred between modules. 

\begin{figure}
    % responsive_image path: assets/img/connector/skirt_pins.svg
    \includegraphics{ skirt_pins.pdf }
    \caption{ \TODO{Graph showing pin layout on PCB inside the skirt} }
\end{figure}

\section{ Connector to Module Interface }
RoFICoM provides \textbf{SPI} interface for communication between module and RoFICoM. The communication on the bus is performed
in transactions. Transaction format consists of \textbf{command}, which is first 8 bits of transaction, followed by \textbf{command
data}, then at least 8 bytes pause with connector response. Commands \numrange{0}{127} are reserved for the base connector and are required to be supported by all
connector types. For example some connector commands are: version command, status command, send and receive earlier
mentioned blob.

\iffalse
<!--
# Peripherals used & what they are used for
- SPI - communication between RoFICoM & Universal module
- UART - debugging communication
- I2C - peripheral communication - lidar
- Motors
- Power management/sharing
- Lidar
-->
\fi

\iffalse
\subsection{ Motivation of RoFICoM }
<!--
_Requirements_:
- able to connect when docks are not touching side by side
- genderless
- connection in four different orientations
- based on a mechanical connection
- disconnect without the participation of the mating side
- support data and power-sharing
-->

Since the RoFI platform is [grid-based]({% link _platform/01_grid-system.md %}), it results in several _requirements_
for both the platform and, more importantly for us, the docking system.
In order to answer "Why do we need it?" let's walk through the _requirements_, their cause and how RoFICoM implements them.

<!-- The first _requirement_ is to **allow modules to connect
when they are not touching side by side**, which is caused by the modules being sphere-shaped, resulting in an empty gap between two adjacent modules. RoFICoM solves this by having a [flat design with expanding and retracting](#mechanical-structure) as it connects and disconnects, respectively. -->
RoFICoM has a flat design with ability to expand and retract. This allows RoFICoM to connect over empty space between
adjacent modules. As result modules don't have to be physically touching to be able to connect.

<!-- The _requirement_ of a **genderless** docking system and the **ability to connect in four different orientations** are to limit the
complexity of configuration and reconfiguration. RoFICoM solves this by being 90-degree symmetrical (see figure below). -->
RoFICoM has 90-degree symmetrical design, this is best seen in figure below on the skirt design. Therefore it enables
RoFICoM to connect in **four different orientations** (0°, 90°, 180°, 270°) and makes the connector **genderless**.

{% responsive_image path: assets/img/connector/skirt_symmetry.svg max_width: "450px" title: "Top down look of skirt symmetry" %}

RoFICoM forms **strong mechanical connection** using previously mentioned clip and skirt. This feature not only helps RoFICoM stay connected under pressure, but also remain connected without electricity consumption or to avoid limitations of magnetic force.

{% responsive_image path: assets/img/connector/locking_process.svg max_width: "450px" title: "Visualization of roficom's locking process." %}

<!-- It is required to be able to **disconnect without the participation of the mating side** to ease reconfiguration. On top of
that, this allows for connection to passive docks. RoFICoM solves this with its mechanical design of the clip and skirt.
The design enables the connector to expand/retract and thus connect to/disconnect from the mating side independently
of the other side. -->
RoFICoM is designed . This design is accomplished by the clip and skirt, which enables **connection between mating sides** to be established **independently of each other**. Additionally this enables the RoFICoM to connect to passive docks.

Last but not least, the docking system must **support data and power
sharing**, which is used to coordinate and charge modules. RoFICoM solves this with a [connector-to-connector
interface](#connector-to-connector-interface).
\fi


\section{ Hardware details }
\TODOLIST{
\begin{itemize}
    \item MCU
    \item motor
    \item UART
    \item SPI
    \item \acrshort{i2c}
    \item EXT and INT power lines
\end{itemize}
}

\acrshort{roficom} is actually split into two boards: \TODO{skirt connector} and \TODO{??system board??}. Those two boards are connected with cable connecting the pins on two boards. The skirt connector board holds \acrshort{lidar} and pins for connector to connector connection (i.e., UART pins -- TX and RX, EXT and INT powerlines, and ``sense`` pins for detecting the orientation of the connection). For the \acrshort{lidar} there are four used pins: two pins for \acrshort{i2c} (SDA and SCL explained in \ref{sec:i2c}), \acrshort{lidar} enable pin and \acrshort{lidar}'s interrupt pin. The skirt connector is placed in the middle of the skirt, thus, moving together with the skirt.

\TODO{??system board??} contains all other necessary circuits for \acrshort{roficom} to function. This consist of foremost the board's microcontroller, motor, power connections, power management, reading current and voltage from power lines (Although the circuit for reading current is not currently attached) and SPI interface needed for connector to module interface.

\TODO{ Missing pins and a change in the motor's limit led to the change of MCU }

The magnetic sensors for the motor's retraction and expansion limit could not detect and stop the movement of the motor fast enough, which damaged the \acrshort{roficom}'s case.
As for the magnetic sensors, instead of two pieces, they got increased to an array of ten pieces along the motor's movement path to determine the motor's speed and position more precisely.

\TODO{describe the MCU and its capabilities}
The \acrshort{roficom} has microcontroller STM32G071CBUx from the STMicroelectronics. This microcontroller from the STM32G0 family is high-performance ARM Cortex-M0+ processor. The main features of this microcontroller are:

\begin{itemize}
    \item Maximum clock frequency of \qty{64}{\mega\hertz},
    \item Biggest size of flash memory in current embedded microcontrollers of \qty{128}{\kilo\byte},
    \item Static RAM of size \qty{36}{\kilo\byte},
    \item 48 pins.
\end{itemize}

The microcontroller has other functionality that is used, such as CRC calculation, SPI, UART, \acrshort{i2c} and many more.


\chapter[ RoFICoM -- what is done and what will be done ]{ \acrshort{roficom} -- what is done and what will be done }
\TODOLIST{
\begin{itemize}
    \item Project structure/architecture
    \begin{itemize}
        \item suites
        \item Protocol
    \end{itemize}
    \item \texttt{control\_board}
    \item \texttt{stm32cxx}
    \item \texttt{rofi-hal}
\end{itemize}
}

\section{ Project Structure / Architecture}
The \acrshort{rofi} repository is an enormous monolithic project and contains plethora \acrshort{rofi} related sub-projects. For this thesis only several sub-projects are important, those sub-projects are the \acrshort{roficom}'s firmware, stm32 drivers and \acrshort{rofi} HAL.

\section[ RoFICoM's Firmware ]{ \acrshort{roficom}'s Firmware }
\acrshort{roficom}'s firmware is located in the repository at the path \path{RoFI/hardwareModules/RoFICoM/software/control_board/}.

\TODO{Stav firmware pred moji bp obsahoval nekolik veci implementovanych}. The implemented features were the \lstinline|spiInterface| (the connector to module interface), \lstinline|connInterface| (the connector to connector interface) and a motor control. However, since the motor control was not able to stop the motor fast enough and the magnetic sensors for detecting the motor position got changed, \TODO{the firmware for motor control needed an update too}. 

\TODO{Protocol -- here or in connector to connector interface}

\section{ Stm32 Drivers }
\TODOLIST{
\begin{itemize}
    \item already implemented
    \item port files -- portability
    \item to implement -- \acrshort{i2c}
\end{itemize}
}

\section[ RoFI HAL ]{ \acrshort{rofi} HAL }
\TODOLIST{
\begin{itemize}
    \item ROFI HAL interface -- current vs changes
    \item ROFI HAL implementation esp32    
\end{itemize}
}

\acrlong{hal}, or \acrshort{hal} for short, is part of the \acrshort{rofi} platform that provides abstraction over running platform, which can be real hardware or a simulator. It can also be used as an abstraction over different \acrshort{rofi} hardware -- modules with motors, sensors and more -- without changing the user firmware. Therefore, \acrshort{rofi} \acrshort{hal} aims to define a solid and compact interface to make both -- the implementation and the usage simpler.

The \acrshort{rofi} \acrshort{hal} is divided into \emph{interface} and \emph{implementation}. \TODO{Text about the interface, that chagnes in the interface are costly.} However, due to the addition of \acrshort{lidar}, \TODO{the interface needs update to reflect this addition}.

The current implementations are esp32 and simulator. The eps32 are the implementation for the \gls{universal-module}.

\chapter[ LiDAR ]{ \acrshort{lidar} } \label{sec:lidar}
\TODOLIST{
\begin{itemize}
    \item \TODO{Walk through \acrshort{lidar} features}
    \item \TODO{Communicating by \acrshort{i2c}}
    \item \TODO{\acrshort{lidar} protocol}
\end{itemize}
}

\acrshort{lidar}, which stands for \acrlong{lidar}, is a device that measures range. \acrshort{lidar} uses laser and time, in which the light travels to an object or a surface and bounces back to determine the distance. Thus, the results of this technique is very dependant on the ambient light in the measured environment. As such, the \acrshort{lidar} is not only used for measuring the distance from an object but also for \emph{3-D scanning}. 3-D scanning is \TODO{collecting data about the real world environment} into a digital representation. Many industries use \acrshort{lidar}, one of the most known use cases might be in NASA's Mars helicopter Ingenuity \cite{garmin-lidar}.

\acrshort{roficom} uses \gls{vl53l1x} \acrshort{lidar} from STMicroelectronics. This specific \acrshort{lidar} has the following main features: (All features and description can be found in the part's datasheet \cite{vl53l1x}.)

\begin{itemize}
    \item the ability to accurately measure the range between \qty{4}{\centi\metre} and \qty{4}{\metre},
    \item up to \qty{50}{\hertz} ranging frequency,
    \item single \qty{2.8}{\volt} power supply,
    \item \acrshort{i2c} communication interface with up to \qty{400}{\kilo\hertz} speed,
    \item shutdown and interrupt pins. (However, these pins are not necessary.)
\end{itemize}

Even though \acrshort{lidar} accurately measures the range between \qty{4}{\centi\metre} and \qty{4}{\metre}, it also measures distances below and above this range, although the measured distance does not have to be accurate. The lidar library, which \acrshort{roficom} uses, deals with inaccuracy by reporting the status of measured data, which is explained later on.

The shutdown pin is used to reset the \acrshort{lidar} by software. That being said, on the actual hardware, the pin is inverted, which results in behavior more similar to enable pin, i.e., the device is enabled when the bus with a shutdown pin is driven high and the device shuts down when the bus is driven low. This pin does not have to be controlled by software. However, in that case, it still has to be connected to the power supply through a pull-up connector, \TODO{which was the case in the \acrshort{roficom} version 0.6}.

On the other hand, the interrupt pin does not require to be connected. This pin signals that the new distance was measured and must be cleared before the next measurement. When the pin is not connected, it is never driven high, and thus the device is in always ready-to-measure state, which can result in missing measurements when the data is not received at the correct time.

The alternative to the interrupt signal is polling. Polling means that the firmware asks the \acrshort{lidar} periodically whether the measurement data are ready to be transmitted. However, if the period is too long, it is possible to miss some measured data. For example, if the inter-measurement timing (the time between two measurements) was \qty{100}{\milli\second} and the firmware's asking period was \qty{500}{\milli\second}, the firmware could miss four measurements from the \acrshort{lidar}. \TODO{Polling was used with \acrshort{roficom} version 0.6 because the MCU did not have available pins for the interrupt pin. Whereas the \acrshort{roficom} version 1.0 is connected and uses the interrupt pin.}

\section{ Communication }
\gls{vl53l1x} uses the \acrshort{i2c} communication protocol. The next subsection describes this protocol, if you are familiar with the protocol you can continue to subsection \ref{sec:lidar-i2c}.

\subsection[ Inter-Integrated Circuit Protocol ]{ \acrlong{i2c} Protocol } \label{sec:i2c}
\acrshort{i2c}, which stands for \acrlong{i2c}, is a protocol designed for communication between a controller (or more controllers) and multiple peripheral devices. The protocol requires only two lines: SDA (serial data) and SCL (serial clock). Both lines are open-drain with pull-up resistors, which means that the bus driver can drive the bus line low but cannot drive it high. This constrain prevents the collision  driving the line both high and low, which would damage the drivers.

The protocol's communication is done in 8-bit packets. The transaction starts with the start condition. After that, every packet is confirmed from the receiving side with one acknowledgment bit, and the transaction ends with the stop condition. Since more peripheral devices can be connected to the \acrshort{i2c} bus, the controller must first address the peripheral to communicate.

The address of a peripheral is either a 7-bit or 10-bit number, where the 10-bit address must be split into two packets with a specified format. The reason why the address is only 7-bit and not the full 8-bits of the packet is because the last bit indicates the transaction type. The transaction type is either read transaction (the bit is set to 0) or write transaction (the bit is set to 1). The read/write bit is the least significant bit of the packet, and the address in contained in the seven highest bits of the packet (i.e. the address is shifted left by one bit). After the address is sent and met with acknowledgment from the peripheral, the data begins to be transmitted. \TODO{The protocol allows for any length of the data to be transmitted.}

The start condition is when the controller drives the SDA line low before the SCL goes down. Stop condition is when the controller releases SDA (the line goes from low to high) \textbf{after} the SCL line changed to high. It is suggested not to change the SDA line while SCL is high to avoid signaling false stop conditions during data transmission. Note that the acknowledgment bit is negated, i.e., logical 0 on the bus line signals that the peripheral received the packet successfully, whereas logical 1 signals the opposite.

This protocol has several advanced topics, such as 10-bit addresses, repeated start conditions, and clock stretching, which are not needed to understand this thesis.

\TODO{Should I write about advanced topics? or at least 10-bit addresses?}

\subsection{ \TODO{Difference in lidar} } \label{sec:lidar-i2c}
Even though the \gls{vl53l1x} uses \acrshort{i2c} protocol, there is a small but significant change in communication. \gls{vl53l1x} not only uses an \acrshort{i2c} address but also requires the address of its register, which is a 16-bit number and \textbf{must} be the first two data packets. The most significant byte of this index is sent first, followed by the least significant byte. Sending the index applies to both types of transactions (read and write). That means that in order to read data from the \acrshort{lidar}, the controller needs to make two transactions: first, a write transaction with register index, and second with the actual read. However, writing data to the \acrshort{lidar} makes only one write transaction because the index and data \textbf{must} be written together in one transaction.

\subsection[ I2C Implementation ]{ \acrshort{i2c} Implementation } \label{sec:lidar-i2c-impl}


\section{ \TODO{Protocol / API} }
Even though \gls{vl53l1x} has clearly defined read and write operations, there is no public specification of how to control the \acrshort{lidar}, i.e. how to initialize the \acrshort{lidar}, start measuring and request the measured data. STMicroelectronics provides and recommends using their software API, in a form of a software driver, to control the \acrshort{lidar}. The driver is a C library and is dual licensed under STMicroelectronics' proprietary license and under BSD 3-clause license, which is compatible with \acrshort{rofi}'s MIT license.

STMicroelectronics provides three driver versions: Full API (standard), \acrlong{uld} (\acrshort{uld}) and Ultra Low Power (ULP). The full API, or standard, driver implements a plethora of functionality together with errors and error messages. The \acrlong{uld} strips down the API only to necessary functionality and calibration, which can be removed if the space is needed. The Ultra Low Power driver aims for the lowest power usage possible.

The \acrlong{uld} was selected for the \acrshort{roficom} because the full API was too large for the firmware. The size of the full api driver's release build took up to \qty{19}{\kilo\byte} of the MCU's Flash. In comparison the release build of \acrlong{uld} takes only \qty{1}{\kilo\byte}. This resulted in missing errors and error messages that was previously used with the full API driver. The \acrshort{uld} only reports failures either caused by lidar (signified as value $1$) or from the under-laying layer (\acrshort{i2c} communication). But in both cases we lose the error message. \todo{How to solve this error handling}.

\section[ API of the Ultra Lite Driver ]{ API of the \acrlong{uld} }
Because the \acrshort{uld} API is platform independent, it requires the user to implement \acrshort{i2c} communication for the platform (the implementation of \acrshort{i2c} in \acrshort{roficom} is described in section \ref{sec:lidar-i2c-impl}). The UM2510 \cite{um2510} manual explains how to use the \acrshort{uld} API and will be described in this section.

The flow of communication is following:

Wait for successful boot of the \acrshort{lidar}.

$\rightarrow$ Initialize the \acrshort{lidar}.

$\rightarrow$ Set optional settings for the \acrshort{lidar}, such as changing the \acrshort{lidar}'s \acrshort{i2c} address, changing the distance mode, changing timings for measurements, \&c.

$\rightarrow$ Start ranging, i.e. start measuring the data.

$\rightarrow$ Wait for the data to be ready -- either by polling or by interrupt.

$\rightarrow$ Receive the data from \acrshort{lidar}.

$\rightarrow$ Prepare for next ranging -- clear the interrupt flag.

$\rightarrow$ Either repeat from waiting for measurements or stop the measuring.

\todo{Insert API flow diagram}

\subsection{ Error Handling }

Since the \acrshort{uld} is a C \TODO{library} the error reporting is the returned value from every API function. \TODO{When results other then errors are needed, those are provided as an ``out'' argument, i.e., pointer to the given variable.}

The error type (\lstinline[breaklines=false]|typedef int8_t VL53L1X_ERROR;|) for the \acrshort{uld} is 8-bit signed integer. The full API driver defines error values among the definition of the error type, however, this is not the case for the \acrshort{uld}. Even though the \acrshort{uld} does not specify error codes, the code for no error is defined to be $0$. Although the \acrshort{uld} usually returns errors from the underlying \acrshort{i2c} communication, in some cases the \acrshort{uld} sets the error to value $1$.

Thus, the typical error handling of the \acrshort{uld} API calls look like the following code listing:

\begin{lstlisting}[float, caption={Structure of error handling of the \acrshort{uld} function calls.}, captionpos=b]
VL53L1X_ERROR status;
status = VL53L1X_SensorInit( ... );
if (status != 0) {
    ... // Report error
    return status;
}

status = VL53L1X_StartRanging( ... );
if (status != 0) {
    ...
    return status;
}
\end{lstlisting}

\subsection{ Distance Modes } \label{distance-modes}

\gls{vl53l1x} has 3 distance modes: \emph{short}, \emph{medium} and \emph{long}. Since the \acrshort{lidar} depends on ambient light, this is when distance modes makes difference. Even though short mode can measure only up to \qty{136}{\centi\metre} it is not as impacted by the ambient light as other modes. In datasheet \cite{vl53l1x} is mentioned that the short distance mode can measure \qty{135}{\centi\metre} under strong ambient light, which is nearly the same as without ambient light. In contrary, the medium and long modes are impacted by the ambient light. Whereas the long mode can measure up to \qty{360}{\centi\metre}, in the strong ambient light it only measured \qty{73}{\centi\metre}.

The \acrshort{uld} provides only two distance modes: short and long. Those modes are described in \ref{distance-modes}. The representation for modes are \lstinline|1| for the short mode, and \lstinline|2| for the long mode. The \acrshort{uld} provides functions \lstinline|VL53L1X_SetDistanceMode()| and \lstinline|VL53L1X_GetDistanceMode()| to set and retrieve current \acrshort{lidar} distance mode.

\subsection{ Timings }

\todo{ Insert timings diagram }

\subsection{ Timing Budget } \label{TB}

\emph{Timing budget} is the time that \acrshort{lidar} measures the distance. \TODO{ Longer timing budget increases the maximum distance \acrshort{lidar} can measure and improves the repeatability error}, but comes at cost of increasing the power consumption. The user can set the timing budget, which is in range from \qtyrange{20}{1000}{\milli\second}. There are few constrains on the timing budget. The minimal budget timing that can be used for all distance modes is \qty{33}{\milli\second}, however the short distance can use lower timings. In order to be able to measure \qty{4}{\metre} in the long distance mode, the timing budget must be at least \qty{140}{\milli\second}.

For the \acrshort{uld}, there is a difference in allowed values \TODO{compared} to the timing budget in the datasheet \cite{vl53l1x}. The allowed values for timing budget in the \acrshort{uld} are only $[15, 20,
33, 50, 100, 200, \qty{500}{\milli\second}]$. \TODO{However the \qty{15}{\milli\second} timing can be only used for the short distance mode}. The default value is set to \qty{100}{\milli\second}.

\subsection{ Inter-Measurement Period }
\emph{Inter-measurement} period is the time between the consecutive measurements. Therefore the inter-measurement period must be longer than the timing budget. The inter-measurement period is also programmable by the user.

The inter-measurement period must be longer than the timing budget. However, the \acrshort{uld} does not validate this and it is left to the user to assure. Otherwise the actual inter-measurement period would be double the expected value. The default value is set to \qty{100}{\milli\second}.

\subsection{ Result Structure }
\TODO{Describe Result structure.}

\begin{lstlisting}
typedef struct {
    uint8_t Status;
    uint16_t Distance;
    uint16_t Ambient;
    uint16_t SigPerSPAD;
    uint16_t NumSPADs;
} VL53L1X_Result_t;
\end{lstlisting}

\TODO{
Most important result is the measured \lstinline|Distance| in \unit{\milli\metre} together with the \lstinline|Status| of the measured distance.
}

\paragraph{\TODO{Status}}

The \acrshort{uld} manual \cite{um2510} documents only five statuses even though, the \gls{vl53l1x} datasheet \cite{vl53l1x} specifies eight. The five statuses with their corresponding values are:
\begin{itemize}
    \item Valid (0)
    \item Sigma failure (1)
    \item Signal failure (2)
    \item Out of bounds (4)
    \item Wraparound (7)
\end{itemize}

The range status of $0$ indicates successful measurement with the measurement data being ready to use.

The sigma failure with value $1$ means that the standard deviation of the measurements had surpassed the expected (normal) values, thus resulting in error. This error can fixed by increasing the timing budget.

The signal failure with value $2$ is caused by \acrshort{lidar} measuring weak signal. The signal rate is represented as a amplitude of the reflected signal from the target. This failure can happen when the target is too far, or is not reflective enough or there is no target at all. Since increasing the timing budget increases the maximum measurable distance it can eliminate this status, but does not have to.

The out of bounds with value $4$ usually occurs when the target is at the maximum possible measurable distance (and it is a very bright target). Subsequently, the measured results may be inconsistent.

The ``wraparound'' range status of value $7$ is reported when the target is very reflective and the distance is longer that the physical limited distance measurable by the \acrshort{lidar}. This distance is \qty{1.3}{\metre} for the short distance mode and \qty{5}{\metre} for the long mode.

\section{ \TODO{ \acrshort{lidar} driver abstraction in \acrshort{roficom} } }

\chapter[BSP]{\acrlong{bsp}} \label{BSP}
\TODOLIST{
\begin{itemize}
    \item \acrshort{bsp} = providing i2c functions to \acrshort{lidar} library + easier portability
    \item \acrshort{bsp} = global namespace \lstinline{Gpio::Pin} initialization is **UB**
\end{itemize}
} 

\acrlong{bsp}, or \acrshort{bsp} for short, is a layer of abstraction specifying  \TODO{minimal needed hardware requirements} for the project, and procedures for board initialization. For example needed pins and peripherals, such as \acrshort{i2c}. 

\TODO{main benefit: single point of gpio definitions, peripheral initialization, ... - enables for easier portability}

\acrshort{bsp} is usually used in embedded environment and provides many benefits. Not only it abstracts hardware details, but also it establishes single source of truth for pin definitions, which is less error prone than having them defined and multiple places. \acrshort{bsp} assures correct initialization of the board at single place. Having everything at single point enables for easier portability across different board versions. The abstraction allows for usage of the \TODO{bsp parts} in different independent parts of the project. 

In \acrshort{roficom}, \acrshort{bsp} is implemented as two files: \verb|bsp.hpp| and \verb|bsp.cpp|. The \verb|bsp.hpp| header file contains all declarations of pins and peripheral drivers, which live in namespace \lstinline{bsp} and are exposed for use in \acrshort{roficom}. However, the function \lstinline{bsp::setupBoard()} \textbf{must} be called before any pin or driver is accessed. The function \lstinline{bsp::setupBoard()} initialized the board, pins and drivers provided in the \lstinline{bsp} namespace. The header file provides declaration of function \lstinline{dbgInstance}, which is function that \acrshort{roficom} uses for debugging with a \TODO{ \texttt{uart} } driver. \verb|bsp.hpp| depends on external function \lstinline|SystemCoreClockUpdate()|, which is \TODO{platform-dependant function} that needs to be called after board clock has been setup. \TODO{In contrary}, the \verb|bsp.cpp| defines and implements everything declared in \verb|bsp.hpp|. 

\verb|bsp.hpp| acts as an interface specifying what drivers and pins \acrshort{roficom} needs to function, however since those pins and drivers are stored as global variables in namespace \lstinline{bsp}, the interface should be kept as minimal as possible to save space in the global space. On the other hand \verb|bsp.cpp| acts as implementation of this interface and should mainly correctly setup the board, pins and drivers for usage, that means the \verb|bsp.cpp| can use pins and drivers that are not exposed as it needs to meet the interface specification.

To illustrate the main benefit of the \acrshort{bsp}, imagine scenario, where we need to change MCU on the board, thus changing pin layout. In this scenario we would only need to change the \verb|bsp.cpp| file with pin definitions (and if not already present implementation of drivers), but the \verb|bsp.hpp| and components built on top of that would be left unchanged and still work.

\section[ Gpio::Pin Initialization ]{ \lstinline|Gpio::Pin| Initialization }
\lstinline{Gpio::Pin} initialization is the most notable and important change in \lstinline{bsp} that differs from all other uses in \acrshort{roficom}. \acrshort{roficom} uses the expression \lstinline{GpioA[ 9 ]} to specify used pins. \lstinline{GpioA}, \lstinline{GpioB} and \lstinline{GpioC} are global objects provided by the \lstinline{Gpio} driver. At the time of writing, the initialization order of global variables across multiple translation unit is not defined by the language specification. As a result \lstinline{bsp} cannot use \lstinline{GpioA}, etc. for pin definitions and instead uses the \lstinline{Gpio::Pin} structure initialization, where first argument is the pin position and second argument is \TODO{the GPIO line defined by STMicroelectronics}.

\chapter[ RoFI HAL ]{ \acrshort{rofi} \acrshort{hal} }

\chapter{ Implementation - Design Decisions }
This chapter walks over interesting design decisions and explains their reasoning.


\section{ Platform Dependant Code -- port files -- \TODO{CRPT} }
\TODOLIST{
\begin{itemize}
    \item comparison CRPT vs inheritance approach
    \item inheritance = vtables can introduce waste of space
\end{itemize}
}

To assure better portability the \verb|stm32cxx| drivers isolate processor family specific code into \emph{port} files. Under the path \path{RoFI/softwareComponents/stm32cxx/port/} are folders for family specific \TODO{abstraction}. The \verb|port| files are in the format \verb|{driver}.port.hpp|. For example the port file for \acrshort{i2c} for the microcontroller of \acrshort{roficom} is in \path{.../stm32cxx/stm32g0xx/i2c.port.hpp}.

Port files follows the same guidelines that the specific code in under \lstinline|namespace detail| and it is implemented via \emph{mixins}. However, since \verb|c++| does not natively support mixins, this is done using the \verb|c++| technique called CRTP. CRTP is a templated class, which takes the class we wish to extend with our mixin as template parameter, and implements the mixin functionality on the template class. Such functionality might be enabling clock for periphery or \TODO{setting alternative function on periphery pins}.

\section[ I2C driver ]{ \acrshort{i2c} driver }
\TODO{Secion intro}

The \acrshort{i2c} driver lies with other \verb|stm32| drivers in project at path \path{RoFI/softwareComponents/stm32cxx/src/drivers/}.

The driver contains class \lstinline|I2C|, \lstinline|SdaPin| and \lstinline|SclPin|, to make the pins distinguishable from \lstinline|Gpio::Pin| i.e., when constructing the \lstinline|I2C| the following construction, where \lstinline|pinSda| and \lstinline|pinScl| are \lstinline|Gpio::Pin|s, \lstinline|I2C(..., pinSda, pinScl)| would fail to compile. On the other hand the construction \lstinline|I2C(..., SdaPin( pinSda ), SclPin( pinScl ) )| compiles. It also ensures that swapping the two pin classes would not compile, i.e., \lstinline|I2C(..., SclPin( ... ), SdaPin( ... ) )| would not compile.

The \acrshort{i2c} driver provides two functions \lstinline|read| and \lstinline|write|. Those functions takes the \acrshort{i2c} address of the peripheral and data container. (There are also \lstinline|unsafe| variants of these functions that are used in \acrshort{lidar} \acrshort{i2c} implementation \ref{sec:lidar-i2c-impl} and takes raw buffer and its size instead of container.) Since the \lstinline|read| and \lstinline|write| are templated functions, they use private functions to actually implement \lstinline|read| and \lstinline|write|. These private functions are not templated and takes the raw buffer and size. Using slim templated function with inner function that is not templated reduces the size of generated functions from template, but allows the usage of generalized function.

\TODO{i2c implementation using stm32 tools}

\subsection{ Error handling }
Since the two functions only takes the arguments either for reading from or writing to the given argument, the functions are free to return anything. In this case they return error. Because the \acrshort{i2c} driver is used in \acrshort{lidar} \acrshort{i2c}, the error values are chosen in a mind to be compatible with error handling in the \acrshort{uld} \ref{uld}. The \acrshort{i2c} error enum has the following errors:
\begin{itemize}
    \item \emph{Valid} value $0$ -- this is to be compatible with the \acrshort{lidar} error reporting,
    \item \emph{Reserved} $1$ -- Reserved for the error reported by the \TODO{...},
    \item \emph{NotAcknowledge} = 2 -- The acknowledgment bit was not signalled after the 8 bits were transmitted,
    \item \emph{BusError} = 3 -- Bus error signals misplaced start or stop condition,
    \item \emph{ArbitrationLoss} -- Arbitration loss occurs when two masters starts transmitting at the same time,
    \item \emph{OverrunUnderrun} -- Overrun is when the newly sent 8-bits are read before the previous 8-bits were read, thus, resulting in data loss. On the other hand, Underrun is when the 8-bits are sent from the data register before the new 8-bits are written into the register, resulting in sending the same 8-bits of data second time,
    \item \emph{BufferOverflow} -- Buffer overflow happens when the receiving data are longer than the allocated buffer to store those data. The data are read until the end of the buffer and the error is reported.
\end{itemize}

\section{ Motor driver }

\section{ Error Handling }
\TODOLIST{
\begin{itemize}
    \item \lstinline{atoms::Result} = exceptions are too heavy for embedded, \lstinline{std::expected} yet to come \texttt{c++23}
    \item the reasoning for given result types - \lstinline{atoms::Void}, \lstinline{std::string_view}
    \item \TODO{error handling in \acrshort{i2c} \& \acrshort{lidar} class}  
\end{itemize}
}

\section{ \TODO{??} }
\TODOLIST{
\begin{itemize}
    \item Hard fault = ram had too high static usage, minimizing the usage by lower the number of available buckets for packets solved this (memory::pool)
\end{itemize}
}

\TODO{At one point} during the development the firmware started hard faulting on the \acrshort{roficom}. Hard faults are exceptions that are typically caused by unrecoverable system errors. Such errors can be an execution of an Undefined instruction, an attempted load or store to an unaligned address, and many more, which are described in more detail in the ARM Devices Generic User Guide.  This resulted in corrupted stack frames during debugging. \TODO{} The Fix to this issue was reducing the size of \TODO{pre-allocated} packet buffer. The count of 1025B buffers was reduced from \TODO{20} to \TODO{5}. \TODO{This seemingly fixed the issue.} 

\section{ \TODO{Size optimization} }
\TODOLIST{
\begin{itemize}
    \item Release build has over 107\% of MCU Flash
    \item `std::bind` -- `1,172B` vs Lambda `972B`
\end{itemize}
}

Function \lstinline|lidarGet()| tries to receive measurement results from the \acrshort{lidar} and assumes that the device is successfully initialized. This function takes a reference to the \lstinline|Lidar| class and variable to store in results. Because \lstinline|lidarGet()| is a polling function it needs to be called indefinitely to constantly update the currently measured distance. Due to the nature of polling, it is needed to poll only when \acrshort{roficom} is idle, otherwise constant polling \TODO{without ...}

\subsection[Ultra Lite LiDAR Library]{Ultra Lite \acrshort{lidar} Library} \label{uld}

\TODOLIST{
\begin{itemize}
    \item Use Low Power version due to saving space in Flash; Release build: full api -- \texttt{\qty{19}{\kilo\byte}} vs ultra lite driver \texttt{\qty{1}{\kilo\byte}}
    \item \TODO{Use `extern "C"` include guards}
\end{itemize}
}


\chapter[RoFICoM 1.0]{ \acrshort{roficom} 1.0 }

New \acrshort{roficom} revision arrived needing firmware updates to reflect changes in hardware.

\TODOLIST{
Changes from version 0.6:
\begin{itemize}
    \item new MCU case with more pins: old = 29, new = 48 pins.
    \item due to a new case, several pins got changed
    \item \acrshort{lidar} changes: MCU pins for enable pin, interrupt pin
    \item Instead of 2 magnetic sensors as the limits of motor rotation, which didn't work quite enough, since the motor wasn't able to stop fast enough, version 2 has an array of 10 magnetic sensors to determine the speed and position of the motor in a more precise manner. 
\end{itemize}
}

On the previous revision, \acrshort{roficom}'s MCU (STM32G071GBU6) had only one last pin left unconnected. The old revision did not have connected \acrshort{lidar}'s enable pin, which meant there was no way to reset the \acrshort{lidar} from the firmware in case of a failure. The interrupt (IRQ) \acrshort{lidar} pin was also not connected in the old revision, but this was not an issue since it could have been solved by polling, as mentioned earlier in \TODO{Add a reference to the explanation of lidar usage}. 

The newly chosen MCU (STM32G071CBUx) has \TODO{48} pins in total, which is a considerable upgrade from the \TODO{29} pins \TODO{that had the previous} MCU. Even though several pins changed \TODO{something is missing here}, reflecting the new hardware revision in the firmware was not as hard because of the usage of \acrshort{bsp}, as explained in section \ref{BSP}. Furthermore, \acrshort{lidar}'s enable and interrupt pins got connected to the MCU's GPIO pins.


\chapter{Conclusion}


\appendix %% Start the appendices.
\chapter{An appendix}
Here you can insert the appendices of your thesis.

\end{document}
